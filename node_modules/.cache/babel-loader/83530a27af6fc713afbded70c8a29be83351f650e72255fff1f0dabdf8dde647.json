{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient } from '@supabase/realtime-js';\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js';\nimport { DEFAULT_HEADERS } from './lib/constants';\nimport { fetchWithAuth } from './lib/fetch';\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\nconst DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n  schema: 'public'\n};\nconst DEFAULT_AUTH_OPTIONS = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n/**\r\n * Supabase Client.\r\n *\r\n * An isomorphic Javascript client for interacting with Postgres.\r\n */\nexport default class SupabaseClient {\n  /**\r\n   * Create a new client for use in the browser.\r\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\r\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\r\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\r\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\r\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\r\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\r\n   * @param options.realtime Options passed along to realtime-js constructor.\r\n   * @param options.global.fetch A custom fetch implementation.\r\n   * @param options.global.headers Any additional headers to send with each network request.\r\n   */\n  constructor(supabaseUrl, supabaseKey, options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.');\n    if (!supabaseKey) throw new Error('supabaseKey is required.');\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws');\n    this.authUrl = `${_supabaseUrl}/auth/v1`;\n    this.storageUrl = `${_supabaseUrl}/storage/v1`;\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split('.');\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`;\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n    }\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`;\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), {\n        storageKey: defaultStorageKey\n      }),\n      global: DEFAULT_GLOBAL_OPTIONS\n    };\n    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n    this.storageKey = (_b = (_a = settings.auth) === null || _a === void 0 ? void 0 : _a.storageKey) !== null && _b !== void 0 ? _b : '';\n    this.headers = (_d = (_c = settings.global) === null || _c === void 0 ? void 0 : _c.headers) !== null && _d !== void 0 ? _d : {};\n    this.auth = this._initSupabaseAuthClient((_e = settings.auth) !== null && _e !== void 0 ? _e : {}, this.headers, (_f = settings.global) === null || _f === void 0 ? void 0 : _f.fetch);\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), (_g = settings.global) === null || _g === void 0 ? void 0 : _g.fetch);\n    this.realtime = this._initRealtimeClient(Object.assign({\n      headers: this.headers\n    }, settings.realtime));\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: (_h = settings.db) === null || _h === void 0 ? void 0 : _h.schema,\n      fetch: this.fetch\n    });\n    this._listenForAuthEvents();\n  }\n  /**\r\n   * Supabase Functions allows you to deploy and invoke edge functions.\r\n   */\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch\n    });\n  }\n  /**\r\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\r\n   */\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch);\n  }\n  from(relation) {\n    return this.rest.from(relation);\n  }\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn  The function name to call.\r\n   * @param args  The parameters to pass to the function call.\r\n   * @param options.head   When set to true, no data will be returned.\r\n   * @param options.count  Count algorithm to use to count rows in a table.\r\n   *\r\n   */\n  rpc(fn) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    return this.rest.rpc(fn, args, options);\n  }\n  /**\r\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\r\n   *\r\n   * @param {string} name - The name of the Realtime channel.\r\n   * @param {Object} opts - The options to pass to the Realtime channel.\r\n   *\r\n   */\n  channel(name) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    return this.realtime.channel(name, opts);\n  }\n  /**\r\n   * Returns all Realtime channels.\r\n   */\n  getChannels() {\n    return this.realtime.getChannels();\n  }\n  /**\r\n   * Unsubscribes and removes Realtime channel from Realtime client.\r\n   *\r\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\r\n   *\r\n   */\n  removeChannel(channel) {\n    return this.realtime.removeChannel(channel);\n  }\n  /**\r\n   * Unsubscribes and removes all Realtime channels from Realtime client.\r\n   */\n  removeAllChannels() {\n    return this.realtime.removeAllChannels();\n  }\n  _getAccessToken() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data\n      } = yield this.auth.getSession();\n      return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;\n    });\n  }\n  _initSupabaseAuthClient(_ref, headers, fetch) {\n    let {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey\n    } = _ref;\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`\n    };\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: Object.assign(Object.assign({}, authHeaders), headers),\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      fetch\n    });\n  }\n  _initRealtimeClient(options) {\n    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {\n      params: Object.assign({\n        apikey: this.supabaseKey\n      }, options === null || options === void 0 ? void 0 : options.params)\n    }));\n  }\n  _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');\n    });\n    return data;\n  }\n  _handleTokenChanged(event, token, source) {\n    if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n      // Token has changed\n      this.realtime.setAuth(token !== null && token !== void 0 ? token : null);\n      this.changedAccessToken = token;\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey);\n      if (source == 'STORAGE') this.auth.signOut();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["FunctionsClient","PostgrestClient","RealtimeClient","StorageClient","SupabaseStorageClient","DEFAULT_HEADERS","fetchWithAuth","stripTrailingSlash","applySettingDefaults","SupabaseAuthClient","DEFAULT_GLOBAL_OPTIONS","headers","DEFAULT_DB_OPTIONS","schema","DEFAULT_AUTH_OPTIONS","autoRefreshToken","persistSession","detectSessionInUrl","DEFAULT_REALTIME_OPTIONS","SupabaseClient","constructor","supabaseUrl","supabaseKey","options","Error","_supabaseUrl","realtimeUrl","replace","authUrl","storageUrl","isPlatform","match","urlParts","split","functionsUrl","defaultStorageKey","URL","hostname","DEFAULTS","db","realtime","auth","storageKey","global","settings","_initSupabaseAuthClient","fetch","_getAccessToken","bind","_initRealtimeClient","rest","_listenForAuthEvents","functions","customFetch","storage","from","relation","rpc","fn","args","channel","name","opts","config","getChannels","removeChannel","removeAllChannels","data","getSession","session","access_token","authHeaders","Authorization","apikey","url","params","onAuthStateChange","event","_handleTokenChanged","token","source","changedAccessToken","setAuth","signOut"],"sources":["C:\\Users\\recar\\Documents\\GitHub\\TILProject\\node_modules\\@supabase\\supabase-js\\src\\SupabaseClient.ts"],"sourcesContent":["import { FunctionsClient } from '@supabase/functions-js'\r\nimport { AuthChangeEvent } from '@supabase/gotrue-js'\r\nimport {\r\n  PostgrestClient,\r\n  PostgrestFilterBuilder,\r\n  PostgrestQueryBuilder,\r\n} from '@supabase/postgrest-js'\r\nimport {\r\n  RealtimeChannel,\r\n  RealtimeChannelOptions,\r\n  RealtimeClient,\r\n  RealtimeClientOptions,\r\n} from '@supabase/realtime-js'\r\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\r\nimport { DEFAULT_HEADERS } from './lib/constants'\r\nimport { fetchWithAuth } from './lib/fetch'\r\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers'\r\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\r\nimport { Fetch, GenericSchema, SupabaseClientOptions, SupabaseAuthClientOptions } from './lib/types'\r\n\r\nconst DEFAULT_GLOBAL_OPTIONS = {\r\n  headers: DEFAULT_HEADERS,\r\n}\r\n\r\nconst DEFAULT_DB_OPTIONS = {\r\n  schema: 'public',\r\n}\r\n\r\nconst DEFAULT_AUTH_OPTIONS: SupabaseAuthClientOptions = {\r\n  autoRefreshToken: true,\r\n  persistSession: true,\r\n  detectSessionInUrl: true,\r\n}\r\n\r\nconst DEFAULT_REALTIME_OPTIONS: RealtimeClientOptions = {}\r\n\r\n/**\r\n * Supabase Client.\r\n *\r\n * An isomorphic Javascript client for interacting with Postgres.\r\n */\r\nexport default class SupabaseClient<\r\n  Database = any,\r\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\r\n    ? 'public'\r\n    : string & keyof Database,\r\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\r\n    ? Database[SchemaName]\r\n    : any\r\n> {\r\n  /**\r\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\r\n   */\r\n  auth: SupabaseAuthClient\r\n\r\n  protected realtimeUrl: string\r\n  protected authUrl: string\r\n  protected storageUrl: string\r\n  protected functionsUrl: string\r\n  protected realtime: RealtimeClient\r\n  protected rest: PostgrestClient<Database, SchemaName>\r\n  protected storageKey: string\r\n  protected fetch?: Fetch\r\n  protected changedAccessToken: string | undefined\r\n\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\r\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\r\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\r\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\r\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\r\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\r\n   * @param options.realtime Options passed along to realtime-js constructor.\r\n   * @param options.global.fetch A custom fetch implementation.\r\n   * @param options.global.headers Any additional headers to send with each network request.\r\n   */\r\n  constructor(\r\n    protected supabaseUrl: string,\r\n    protected supabaseKey: string,\r\n    options?: SupabaseClientOptions<SchemaName>\r\n  ) {\r\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\r\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\r\n\r\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\r\n\r\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws')\r\n    this.authUrl = `${_supabaseUrl}/auth/v1`\r\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\r\n\r\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/)\r\n    if (isPlatform) {\r\n      const urlParts = _supabaseUrl.split('.')\r\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`\r\n    } else {\r\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`\r\n    }\r\n    // default storage key uses the supabase project ref as a namespace\r\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`\r\n    const DEFAULTS = {\r\n      db: DEFAULT_DB_OPTIONS,\r\n      realtime: DEFAULT_REALTIME_OPTIONS,\r\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\r\n      global: DEFAULT_GLOBAL_OPTIONS,\r\n    }\r\n\r\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\r\n\r\n    this.storageKey = settings.auth?.storageKey ?? ''\r\n    this.headers = settings.global?.headers ?? {}\r\n\r\n    this.auth = this._initSupabaseAuthClient(\r\n      settings.auth ?? {},\r\n      this.headers,\r\n      settings.global?.fetch\r\n    )\r\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global?.fetch)\r\n\r\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\r\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\r\n      headers: this.headers,\r\n      schema: settings.db?.schema,\r\n      fetch: this.fetch,\r\n    })\r\n\r\n    this._listenForAuthEvents()\r\n  }\r\n\r\n  /**\r\n   * Supabase Functions allows you to deploy and invoke edge functions.\r\n   */\r\n  get functions() {\r\n    return new FunctionsClient(this.functionsUrl, {\r\n      headers: this.headers,\r\n      customFetch: this.fetch,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\r\n   */\r\n  get storage() {\r\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch)\r\n  }\r\n\r\n  /**\r\n   * Perform a table operation.\r\n   *\r\n   * @param table The table name to operate on.\r\n   */\r\n  from<\r\n    TableName extends string & keyof Schema['Tables'],\r\n    Table extends Schema['Tables'][TableName]\r\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\r\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\r\n    relation: ViewName\r\n  ): PostgrestQueryBuilder<Schema, View>\r\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\r\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\r\n    return this.rest.from(relation)\r\n  }\r\n\r\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn  The function name to call.\r\n   * @param args  The parameters to pass to the function call.\r\n   * @param options.head   When set to true, no data will be returned.\r\n   * @param options.count  Count algorithm to use to count rows in a table.\r\n   *\r\n   */\r\n  rpc<\r\n    FunctionName extends string & keyof Schema['Functions'],\r\n    Function_ extends Schema['Functions'][FunctionName]\r\n  >(\r\n    fn: FunctionName,\r\n    args: Function_['Args'] = {},\r\n    options?: {\r\n      head?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    }\r\n  ): PostgrestFilterBuilder<\r\n    Schema,\r\n    Function_['Returns'] extends any[]\r\n      ? Function_['Returns'][number] extends Record<string, unknown>\r\n        ? Function_['Returns'][number]\r\n        : never\r\n      : never,\r\n    Function_['Returns']\r\n  > {\r\n    return this.rest.rpc(fn, args, options)\r\n  }\r\n\r\n  /**\r\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\r\n   *\r\n   * @param {string} name - The name of the Realtime channel.\r\n   * @param {Object} opts - The options to pass to the Realtime channel.\r\n   *\r\n   */\r\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\r\n    return this.realtime.channel(name, opts)\r\n  }\r\n\r\n  /**\r\n   * Returns all Realtime channels.\r\n   */\r\n  getChannels(): RealtimeChannel[] {\r\n    return this.realtime.getChannels()\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes Realtime channel from Realtime client.\r\n   *\r\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\r\n   *\r\n   */\r\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\r\n    return this.realtime.removeChannel(channel)\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes all Realtime channels from Realtime client.\r\n   */\r\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\r\n    return this.realtime.removeAllChannels()\r\n  }\r\n\r\n  private async _getAccessToken() {\r\n    const { data } = await this.auth.getSession()\r\n\r\n    return data.session?.access_token ?? null\r\n  }\r\n\r\n  private _initSupabaseAuthClient(\r\n    {\r\n      autoRefreshToken,\r\n      persistSession,\r\n      detectSessionInUrl,\r\n      storage,\r\n      storageKey,\r\n    }: SupabaseAuthClientOptions,\r\n    headers?: Record<string, string>,\r\n    fetch?: Fetch\r\n  ) {\r\n    const authHeaders = {\r\n      Authorization: `Bearer ${this.supabaseKey}`,\r\n      apikey: `${this.supabaseKey}`,\r\n    }\r\n    return new SupabaseAuthClient({\r\n      url: this.authUrl,\r\n      headers: { ...authHeaders, ...headers },\r\n      storageKey: storageKey,\r\n      autoRefreshToken,\r\n      persistSession,\r\n      detectSessionInUrl,\r\n      storage,\r\n      fetch,\r\n    })\r\n  }\r\n\r\n  private _initRealtimeClient(options: RealtimeClientOptions) {\r\n    return new RealtimeClient(this.realtimeUrl, {\r\n      ...options,\r\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\r\n    })\r\n  }\r\n\r\n  private _listenForAuthEvents() {\r\n    let data = this.auth.onAuthStateChange((event, session) => {\r\n      this._handleTokenChanged(event, session?.access_token, 'CLIENT')\r\n    })\r\n    return data\r\n  }\r\n\r\n  private _handleTokenChanged(\r\n    event: AuthChangeEvent,\r\n    token: string | undefined,\r\n    source: 'CLIENT' | 'STORAGE'\r\n  ) {\r\n    if (\r\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\r\n      this.changedAccessToken !== token\r\n    ) {\r\n      // Token has changed\r\n      this.realtime.setAuth(token ?? null)\r\n\r\n      this.changedAccessToken = token\r\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\r\n      // Token is removed\r\n      this.realtime.setAuth(this.supabaseKey)\r\n      if (source == 'STORAGE') this.auth.signOut()\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}