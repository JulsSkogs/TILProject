{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n **/\nexport default class RealtimeChannel {\n  constructor( /** Topic name can be any string. */\n  topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    let socket = arguments.length > 2 ? arguments[2] : undefined;\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n  }\n  /** Subscribe registers your client with the server */\n  subscribe(callback) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;\n    var _a, _b;\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const {\n        config: {\n          broadcast,\n          presence\n        }\n      } = this.params;\n      this._onError(e => callback && callback('CHANNEL_ERROR', e));\n      this._onClose(() => callback && callback('CLOSED'));\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : []\n      };\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken;\n      }\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive('ok', _ref2 => {\n        let {\n          postgres_changes: serverPostgresFilters\n        } = _ref2;\n        var _a;\n        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);\n        if (serverPostgresFilters === undefined) {\n          callback && callback('SUBSCRIBED');\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback('SUBSCRIBED');\n          return;\n        }\n      }).receive('error', error => {\n        callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback && callback('TIMED_OUT');\n        return;\n      });\n    }\n    return this;\n  }\n  presenceState() {\n    return this.presence.state;\n  }\n  track(payload) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: 'presence',\n        event: 'track',\n        payload\n      }, opts.timeout || this.timeout);\n    });\n  }\n  untrack() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: 'presence',\n        event: 'untrack'\n      }, opts);\n    });\n  }\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n  send(payload) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise(resolve => {\n      var _a, _b, _c;\n      const push = this._push(payload.type, payload, opts.timeout || this.timeout);\n      if (push.rateLimited) {\n        resolve('rate limited');\n      }\n      if (payload.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n        resolve('ok');\n      }\n      push.receive('ok', () => resolve('ok'));\n      push.receive('timeout', () => resolve('timed out'));\n    });\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\r\n   * Leaves the channel.\r\n   *\r\n   * Unsubscribes from server events, and instructs channel to terminate on server.\r\n   * Triggers onClose() hooks.\r\n   *\r\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n   */\n  unsubscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n    this.rejoinTimer.reset();\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy();\n    return new Promise(resolve => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    });\n  }\n  /** @internal */\n  _push(event, payload) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  /**\r\n   * Overridable message hook\r\n   *\r\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n   * Must return the payload, modified or unmodified.\r\n   *\r\n   * @internal\r\n   */\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  /** @internal */\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n      var _a;\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  /** @internal */\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\r\n   * Registers a callback that will be executed when the channel closes.\r\n   *\r\n   * @internal\r\n   */\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\r\n   * Registers a callback that will be executed when the channel encounteres an error.\r\n   *\r\n   * @internal\r\n   */\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\r\n   * Returns `true` if the socket is connected and the channel has been joined.\r\n   *\r\n   * @internal\r\n   */\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n  _rejoin() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n}","map":{"version":3,"mappings":"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","names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","Transformers","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","RealtimeChannel","constructor","topic","params","config","socket","closed","broadcast","ack","self","presence","key","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","state","joined","reset","pushBuffer","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","subscribe","callback","joinedOnce","e","accessTokenPayload","postgres_changes","bindings","map","r","filter","accessToken","access_token","updateJoinPayload","_rejoin","serverPostgresFilters","setAuth","undefined","clientPostgresBindings","bindingsLen","length","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","Object","values","presenceState","track","opts","type","untrack","on","Promise","resolve","_push","rateLimited","updatePayload","leaving","onClose","close","destroy","leavePush","leave","_canPush","trigger","startTimeout","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","bindId","bindEvent","ids","data","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","isConnected","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["C:\\Users\\recar\\Documents\\GitHub\\TILProject\\node_modules\\@supabase\\realtime-js\\src\\RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\r\nimport Push from './lib/push'\r\nimport RealtimeClient from './RealtimeClient'\r\nimport Timer from './lib/timer'\r\nimport RealtimePresence, {\r\n  RealtimePresenceJoinPayload,\r\n  RealtimePresenceLeavePayload,\r\n  RealtimePresenceState,\r\n  REALTIME_PRESENCE_LISTEN_EVENTS,\r\n} from './RealtimePresence'\r\nimport * as Transformers from './lib/transformers'\r\n\r\nexport type RealtimeChannelOptions = {\r\n  config: {\r\n    /**\r\n     * self option enables client to receive message it broadcast\r\n     * ack option instructs server to acknowlege that broadcast message was received\r\n     */\r\n    broadcast?: { self?: boolean; ack?: boolean }\r\n    /**\r\n     * key option is used to track presence payload across clients\r\n     */\r\n    presence?: { key?: string }\r\n  }\r\n}\r\n\r\ntype RealtimePostgresChangesPayloadBase = {\r\n  schema: string\r\n  table: string\r\n  commit_timestamp: string\r\n  errors: string[]\r\n}\r\n\r\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\r\n    new: T\r\n    old: {}\r\n  }\r\n\r\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\r\n    new: T\r\n    old: Partial<T>\r\n  }\r\n\r\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\r\n  RealtimePostgresChangesPayloadBase & {\r\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\r\n    new: {}\r\n    old: Partial<T>\r\n  }\r\n\r\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\r\n  | RealtimePostgresInsertPayload<T>\r\n  | RealtimePostgresUpdatePayload<T>\r\n  | RealtimePostgresDeletePayload<T>\r\n\r\nexport type RealtimePostgresChangesFilter<T extends string> = {\r\n  event: T\r\n  schema: string\r\n  table?: string\r\n  filter?: string\r\n}\r\n\r\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'rate limited'\r\n\r\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\r\n  ALL = '*',\r\n  INSERT = 'INSERT',\r\n  UPDATE = 'UPDATE',\r\n  DELETE = 'DELETE',\r\n}\r\n\r\nexport enum REALTIME_LISTEN_TYPES {\r\n  BROADCAST = 'broadcast',\r\n  PRESENCE = 'presence',\r\n  POSTGRES_CHANGES = 'postgres_changes',\r\n}\r\n\r\nexport enum REALTIME_SUBSCRIBE_STATES {\r\n  SUBSCRIBED = 'SUBSCRIBED',\r\n  TIMED_OUT = 'TIMED_OUT',\r\n  CLOSED = 'CLOSED',\r\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\r\n}\r\n\r\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n **/\r\nexport default class RealtimeChannel {\r\n  bindings: {\r\n    [key: string]: {\r\n      type: string\r\n      filter: { [key: string]: any }\r\n      callback: Function\r\n      id?: string\r\n    }[]\r\n  } = {}\r\n  timeout: number\r\n  state = CHANNEL_STATES.closed\r\n  joinedOnce = false\r\n  joinPush: Push\r\n  rejoinTimer: Timer\r\n  pushBuffer: Push[] = []\r\n  presence: RealtimePresence\r\n\r\n  constructor(\r\n    /** Topic name can be any string. */\r\n    public topic: string,\r\n    public params: RealtimeChannelOptions = { config: {} },\r\n    public socket: RealtimeClient\r\n  ) {\r\n    this.params.config = {\r\n      ...{\r\n        broadcast: { ack: false, self: false },\r\n        presence: { key: '' },\r\n      },\r\n      ...params.config,\r\n    }\r\n    this.timeout = this.socket.timeout\r\n    this.joinPush = new Push(\r\n      this,\r\n      CHANNEL_EVENTS.join,\r\n      this.params,\r\n      this.timeout\r\n    )\r\n    this.rejoinTimer = new Timer(\r\n      () => this._rejoinUntilConnected(),\r\n      this.socket.reconnectAfterMs\r\n    )\r\n    this.joinPush.receive('ok', () => {\r\n      this.state = CHANNEL_STATES.joined\r\n      this.rejoinTimer.reset()\r\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\r\n      this.pushBuffer = []\r\n    })\r\n    this._onClose(() => {\r\n      this.rejoinTimer.reset()\r\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\r\n      this.state = CHANNEL_STATES.closed\r\n      this.socket._remove(this)\r\n    })\r\n    this._onError((reason: string) => {\r\n      if (this._isLeaving() || this._isClosed()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `error ${this.topic}`, reason)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this.joinPush.receive('timeout', () => {\r\n      if (!this._isJoining()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\r\n      this._trigger(this._replyEventName(ref), payload)\r\n    })\r\n\r\n    this.presence = new RealtimePresence(this)\r\n  }\r\n\r\n  /** Subscribe registers your client with the server */\r\n  subscribe(\r\n    callback?: (status: `${REALTIME_SUBSCRIBE_STATES}`, err?: Error) => void,\r\n    timeout = this.timeout\r\n  ): RealtimeChannel {\r\n    if (this.joinedOnce) {\r\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\r\n    } else {\r\n      const {\r\n        config: { broadcast, presence },\r\n      } = this.params\r\n      this._onError((e: Error) => callback && callback('CHANNEL_ERROR', e))\r\n      this._onClose(() => callback && callback('CLOSED'))\r\n\r\n      const accessTokenPayload: { access_token?: string } = {}\r\n      const config = {\r\n        broadcast,\r\n        presence,\r\n        postgres_changes:\r\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\r\n      }\r\n\r\n      if (this.socket.accessToken) {\r\n        accessTokenPayload.access_token = this.socket.accessToken\r\n      }\r\n\r\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\r\n\r\n      this.joinedOnce = true\r\n      this._rejoin(timeout)\r\n\r\n      this.joinPush\r\n        .receive(\r\n          'ok',\r\n          ({\r\n            postgres_changes: serverPostgresFilters,\r\n          }: {\r\n            postgres_changes: {\r\n              id: string\r\n              event: string\r\n              schema?: string\r\n              table?: string\r\n              filter?: string\r\n            }[]\r\n          }) => {\r\n            this.socket.accessToken &&\r\n              this.socket.setAuth(this.socket.accessToken)\r\n\r\n            if (serverPostgresFilters === undefined) {\r\n              callback && callback('SUBSCRIBED')\r\n              return\r\n            } else {\r\n              const clientPostgresBindings = this.bindings.postgres_changes\r\n              const bindingsLen = clientPostgresBindings?.length ?? 0\r\n              const newPostgresBindings = []\r\n\r\n              for (let i = 0; i < bindingsLen; i++) {\r\n                const clientPostgresBinding = clientPostgresBindings[i]\r\n                const {\r\n                  filter: { event, schema, table, filter },\r\n                } = clientPostgresBinding\r\n                const serverPostgresFilter =\r\n                  serverPostgresFilters && serverPostgresFilters[i]\r\n\r\n                if (\r\n                  serverPostgresFilter &&\r\n                  serverPostgresFilter.event === event &&\r\n                  serverPostgresFilter.schema === schema &&\r\n                  serverPostgresFilter.table === table &&\r\n                  serverPostgresFilter.filter === filter\r\n                ) {\r\n                  newPostgresBindings.push({\r\n                    ...clientPostgresBinding,\r\n                    id: serverPostgresFilter.id,\r\n                  })\r\n                } else {\r\n                  this.unsubscribe()\r\n                  callback &&\r\n                    callback(\r\n                      'CHANNEL_ERROR',\r\n                      new Error(\r\n                        'mismatch between server and client bindings for postgres changes'\r\n                      )\r\n                    )\r\n                  return\r\n                }\r\n              }\r\n\r\n              this.bindings.postgres_changes = newPostgresBindings\r\n\r\n              callback && callback('SUBSCRIBED')\r\n              return\r\n            }\r\n          }\r\n        )\r\n        .receive('error', (error: { [key: string]: any }) => {\r\n          callback &&\r\n            callback(\r\n              'CHANNEL_ERROR',\r\n              new Error(\r\n                JSON.stringify(Object.values(error).join(', ') || 'error')\r\n              )\r\n            )\r\n          return\r\n        })\r\n        .receive('timeout', () => {\r\n          callback && callback('TIMED_OUT')\r\n          return\r\n        })\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  presenceState(): RealtimePresenceState {\r\n    return this.presence.state\r\n  }\r\n\r\n  async track(\r\n    payload: { [key: string]: any },\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    return await this.send(\r\n      {\r\n        type: 'presence',\r\n        event: 'track',\r\n        payload,\r\n      },\r\n      opts.timeout || this.timeout\r\n    )\r\n  }\r\n\r\n  async untrack(\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    return await this.send(\r\n      {\r\n        type: 'presence',\r\n        event: 'untrack',\r\n      },\r\n      opts\r\n    )\r\n  }\r\n\r\n  /** Listen to messages. */\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\r\n    filter: { event: string },\r\n    callback: (payload: {\r\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\r\n      event: string\r\n      [key: string]: any\r\n    }) => void\r\n  ): RealtimeChannel\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\r\n    callback: () => void\r\n  ): RealtimeChannel\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\r\n    callback: (payload: RealtimePresenceJoinPayload) => void\r\n  ): RealtimeChannel\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\r\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\r\n    callback: (payload: RealtimePresenceLeavePayload) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\r\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\r\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\r\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\r\n  ): RealtimeChannel\r\n  on<T extends { [key: string]: any }>(\r\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\r\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\r\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\r\n  ): RealtimeChannel\r\n  on(\r\n    type: `${REALTIME_LISTEN_TYPES}`,\r\n    filter: { event: string; [key: string]: string },\r\n    callback: (payload: any) => void\r\n  ): RealtimeChannel {\r\n    return this._on(type, filter, callback)\r\n  }\r\n\r\n  send(\r\n    payload: { type: string; [key: string]: any },\r\n    opts: { [key: string]: any } = {}\r\n  ): Promise<RealtimeChannelSendResponse> {\r\n    return new Promise((resolve) => {\r\n      const push = this._push(\r\n        payload.type,\r\n        payload,\r\n        opts.timeout || this.timeout\r\n      )\r\n\r\n      if (push.rateLimited) {\r\n        resolve('rate limited')\r\n      }\r\n\r\n      if (\r\n        payload.type === 'broadcast' &&\r\n        !this.params?.config?.broadcast?.ack\r\n      ) {\r\n        resolve('ok')\r\n      }\r\n\r\n      push.receive('ok', () => resolve('ok'))\r\n      push.receive('timeout', () => resolve('timed out'))\r\n    })\r\n  }\r\n\r\n  updateJoinPayload(payload: { [key: string]: any }): void {\r\n    this.joinPush.updatePayload(payload)\r\n  }\r\n\r\n  /**\r\n   * Leaves the channel.\r\n   *\r\n   * Unsubscribes from server events, and instructs channel to terminate on server.\r\n   * Triggers onClose() hooks.\r\n   *\r\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n   */\r\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\r\n    this.state = CHANNEL_STATES.leaving\r\n    const onClose = () => {\r\n      this.socket.log('channel', `leave ${this.topic}`)\r\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\r\n    }\r\n\r\n    this.rejoinTimer.reset()\r\n    // Destroy joinPush to avoid connection timeouts during unscription phase\r\n    this.joinPush.destroy()\r\n\r\n    return new Promise((resolve) => {\r\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\r\n\r\n      leavePush\r\n        .receive('ok', () => {\r\n          onClose()\r\n          resolve('ok')\r\n        })\r\n        .receive('timeout', () => {\r\n          onClose()\r\n          resolve('timed out')\r\n        })\r\n        .receive('error', () => {\r\n          resolve('error')\r\n        })\r\n\r\n      leavePush.send()\r\n\r\n      if (!this._canPush()) {\r\n        leavePush.trigger('ok', {})\r\n      }\r\n    })\r\n  }\r\n\r\n  /** @internal */\r\n  _push(\r\n    event: string,\r\n    payload: { [key: string]: any },\r\n    timeout = this.timeout\r\n  ) {\r\n    if (!this.joinedOnce) {\r\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\r\n    }\r\n    let pushEvent = new Push(this, event, payload, timeout)\r\n    if (this._canPush()) {\r\n      pushEvent.send()\r\n    } else {\r\n      pushEvent.startTimeout()\r\n      this.pushBuffer.push(pushEvent)\r\n    }\r\n\r\n    return pushEvent\r\n  }\r\n\r\n  /**\r\n   * Overridable message hook\r\n   *\r\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n   * Must return the payload, modified or unmodified.\r\n   *\r\n   * @internal\r\n   */\r\n  _onMessage(_event: string, payload: any, _ref?: string) {\r\n    return payload\r\n  }\r\n\r\n  /** @internal */\r\n  _isMember(topic: string): boolean {\r\n    return this.topic === topic\r\n  }\r\n\r\n  /** @internal */\r\n  _joinRef(): string {\r\n    return this.joinPush.ref\r\n  }\r\n\r\n  /** @internal */\r\n  _trigger(type: string, payload?: any, ref?: string) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n    const { close, error, leave, join } = CHANNEL_EVENTS\r\n    const events: string[] = [close, error, leave, join]\r\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\r\n      return\r\n    }\r\n    let handledPayload = this._onMessage(typeLower, payload, ref)\r\n    if (payload && !handledPayload) {\r\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\r\n    }\r\n\r\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\r\n      this.bindings.postgres_changes\r\n        ?.filter((bind) => {\r\n          return (\r\n            bind.filter?.event === '*' ||\r\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\r\n          )\r\n        })\r\n        .map((bind) => bind.callback(handledPayload, ref))\r\n    } else {\r\n      this.bindings[typeLower]\r\n        ?.filter((bind) => {\r\n          if (\r\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\r\n          ) {\r\n            if ('id' in bind) {\r\n              const bindId = bind.id\r\n              const bindEvent = bind.filter?.event\r\n              return (\r\n                bindId &&\r\n                payload.ids?.includes(bindId) &&\r\n                (bindEvent === '*' ||\r\n                  bindEvent?.toLocaleLowerCase() ===\r\n                    payload.data?.type.toLocaleLowerCase())\r\n              )\r\n            } else {\r\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\r\n              return (\r\n                bindEvent === '*' ||\r\n                bindEvent === payload?.event?.toLocaleLowerCase()\r\n              )\r\n            }\r\n          } else {\r\n            return bind.type.toLocaleLowerCase() === typeLower\r\n          }\r\n        })\r\n        .map((bind) => {\r\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\r\n            const postgresChanges = handledPayload.data\r\n            const { schema, table, commit_timestamp, type, errors } =\r\n              postgresChanges\r\n            const enrichedPayload = {\r\n              schema: schema,\r\n              table: table,\r\n              commit_timestamp: commit_timestamp,\r\n              eventType: type,\r\n              new: {},\r\n              old: {},\r\n              errors: errors,\r\n            }\r\n            handledPayload = {\r\n              ...enrichedPayload,\r\n              ...this._getPayloadRecords(postgresChanges),\r\n            }\r\n          }\r\n          bind.callback(handledPayload, ref)\r\n        })\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  _isClosed(): boolean {\r\n    return this.state === CHANNEL_STATES.closed\r\n  }\r\n\r\n  /** @internal */\r\n  _isJoined(): boolean {\r\n    return this.state === CHANNEL_STATES.joined\r\n  }\r\n\r\n  /** @internal */\r\n  _isJoining(): boolean {\r\n    return this.state === CHANNEL_STATES.joining\r\n  }\r\n\r\n  /** @internal */\r\n  _isLeaving(): boolean {\r\n    return this.state === CHANNEL_STATES.leaving\r\n  }\r\n\r\n  /** @internal */\r\n  _replyEventName(ref: string): string {\r\n    return `chan_reply_${ref}`\r\n  }\r\n\r\n  /** @internal */\r\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n\r\n    const binding = {\r\n      type: typeLower,\r\n      filter: filter,\r\n      callback: callback,\r\n    }\r\n\r\n    if (this.bindings[typeLower]) {\r\n      this.bindings[typeLower].push(binding)\r\n    } else {\r\n      this.bindings[typeLower] = [binding]\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /** @internal */\r\n  _off(type: string, filter: { [key: string]: any }) {\r\n    const typeLower = type.toLocaleLowerCase()\r\n\r\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\r\n      return !(\r\n        bind.type?.toLocaleLowerCase() === typeLower &&\r\n        RealtimeChannel.isEqual(bind.filter, filter)\r\n      )\r\n    })\r\n    return this\r\n  }\r\n\r\n  /** @internal */\r\n  private static isEqual(\r\n    obj1: { [key: string]: string },\r\n    obj2: { [key: string]: string }\r\n  ) {\r\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\r\n      return false\r\n    }\r\n\r\n    for (const k in obj1) {\r\n      if (obj1[k] !== obj2[k]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /** @internal */\r\n  private _rejoinUntilConnected() {\r\n    this.rejoinTimer.scheduleTimeout()\r\n    if (this.socket.isConnected()) {\r\n      this._rejoin()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a callback that will be executed when the channel closes.\r\n   *\r\n   * @internal\r\n   */\r\n  private _onClose(callback: Function) {\r\n    this._on(CHANNEL_EVENTS.close, {}, callback)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback that will be executed when the channel encounteres an error.\r\n   *\r\n   * @internal\r\n   */\r\n  private _onError(callback: Function) {\r\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the socket is connected and the channel has been joined.\r\n   *\r\n   * @internal\r\n   */\r\n  private _canPush(): boolean {\r\n    return this.socket.isConnected() && this._isJoined()\r\n  }\r\n\r\n  /** @internal */\r\n  private _rejoin(timeout = this.timeout): void {\r\n    if (this._isLeaving()) {\r\n      return\r\n    }\r\n    this.socket._leaveOpenTopic(this.topic)\r\n    this.state = CHANNEL_STATES.joining\r\n    this.joinPush.resend(timeout)\r\n  }\r\n\r\n  /** @internal */\r\n  private _getPayloadRecords(payload: any) {\r\n    const records = {\r\n      new: {},\r\n      old: {},\r\n    }\r\n\r\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\r\n      records.new = Transformers.convertChangeData(\r\n        payload.columns,\r\n        payload.record\r\n      )\r\n    }\r\n\r\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\r\n      records.old = Transformers.convertChangeData(\r\n        payload.columns,\r\n        payload.old_record\r\n      )\r\n    }\r\n\r\n    return records\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}